# 3.1 如何压缩

以 OP-Rollup 的为例，我们要向 Layer 1 上传一段时间内的所有交易详情，如果不对这部分数据进行高度压缩，那分担负载的效果就非常小了。我们以单笔交易为例，它身上其实有许多可改进的空间。

比如一笔常见的转账交易，它的原数交易数据可能是以下这样的：

**4232f461**000000000000000000000000**7ea2be2df7ba6e54b1a9c70676f668455e329d29**000000000000000000000000**d548a5e31de2b4c2681a58a3be5302abcae4bc57**00000000000000000000**000000000000000000000000000000000000000186a0**

（**Method ID** / 填充的 0 <sup>[1]</sup> / **代币合约地址** / 填充的 0 / **收款的账户地址** / 填充的 0 / **提币数量**）

&nbsp;

原始交易数据可以通过以下手段压缩：

1. 用**科学计数法** <sup>[2]</sup> 把转账数量压缩成 64 位数据，并删除不必要的 0。（数量的精度会略微下降，但实践中影响不大）
2. 调用的方法如果很常见，可以删除所调用的 Method ID，因为如“转账一笔 ERC20 <sup>[3]</sup> 代币”的交易，可以通过交易内容的特征推测
3. 常用行为设置绿色通道（Helper ID）：大部分发送代币的行为都是如 USDC、WETH 等常用代币，可以用更短的一个 Helper ID，来表示调用方法是“发送”，发送的代币是“USDC”这两个信息。
4. 登记一个“电话簿”，记录收款人地址，将 40 位的地址压缩为第 XXX 页的第 X 个地址。
5. 如果发送的是 ETH，连 Helper ID 都可以省掉。

&nbsp;

最终我们需要上传至 Layer 1 的数据从一段非常长的信息

**4232f461**000000000000000000000000**7ea2be2df7ba6e54b1a9c70676f668455e329d29**000000000000000000000000**d548a5e31de2b4c2681a58a3be5302abcae4bc57**00000000000000000000**000000000000000000000000000000000000000186a0**

变为了

**059c57**0186a0

（**收款账户“电话簿”编号** / 提币数量）

 <CompressText />

&nbsp;

Layer 1 存储数据的成本是非常高昂的，Layer 2 的执行成本绝大部分的都消耗在了这一步，因此压缩需要上传的数据上可以显著降低 Layer 2 整体的交易成本。除了以上压缩手段以外，**还有进一步压缩的空间吗**？

&nbsp; 
## 注释及拓展阅读

<sup>[1]</sup> 需要填充 0 来占位是因为以太坊的交易数据是按固定长度来编码的，如 Method ID 占 128 位（即 32 个十六进制字母），地址和数量占 256 位（即 64 个十六进制字母），信息字段长度不足的则需要用 0 来填充，以保持数据的对齐和一致性。

<sup>[2]</sup> 科学记数法是一种记数的方法。 把一个数表示成 a 与 10 的 n 次幂相乘的形式（1 ≤ |a| < 10 ，a 不为分数，n 为整数），这种记数法叫做科学记数法。 如 19971400000000 表示为 1.99714 × 10<sup>13</sup>。

<sup>[3]</sup> ERC20 是第 20 号以太坊改进提案（Ethereum Request for Comments 即“以太坊征求意见”）。ERC20 是最常见的代币标准之一，规定了代币名、精度、授权额度等标准。如 USDC、WETH、WBTC 等都是 ERC20 代币。


<GithubAvatar owner='lxdao-official' repo='myfirstlayer2-frontend' path='mdx/zh/3.1-compress.md' />

<EditChapter url='https://github.com/lxdao-official/myfirstlayer2-frontend/blob/main/mdx/zh/3.1-compress.md' />
